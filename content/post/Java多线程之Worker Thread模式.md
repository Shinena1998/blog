---
title: "Java多线程之Worker Thread模式"
date: 2019-03-21T00:14:14+08:00
categories:
  - Java
tags:
  - Thread
draft: false
---

在java中，如果每个请求到达就创建一个新线程，开销是相当大的。在实际使用中，服务器在创建和销毁线程上花费的时间和消耗的系统资源都相当大，甚至可能要比在处理实际的用户请求的时间和资源要多的多。除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。如果在一个jvm里创建太多的线程，可能会使系统由于过度消耗内存或“切换过度”而导致系统资源不足。为了防止资源不足，服务器应用程序需要采取一些办法来限制任何给定时刻处理的请求数目，尽可能减少创建和销毁线程的次数，特别是一些资源耗费比较大的线程的创建和销毁，尽量利用已有对象来进行服务，这就是“池化资源”技术产生的原因。    <br /><br />
<a name="16c682b8"></a>
#### 创建线程的过程
> 关于时间，创建线程使用是直接向系统申请资源的，这里调用系统函数进行分配资源的话耗时不好说。


> 关于资源,Java线程的线程栈所占用的内存是在Java堆外的，所以是不受java程序控制的，只受系统资源限制，默认一个线程的线程栈大小是1M（当让这个可以通过设置-Xss属性设置，但是要注意栈溢出问题），但是，如果每个用户请求都新建线程的话，1024个用户光线程就占用了1个G的内存，如果系统比较大的话，一下子系统资源就不够用了，最后程序就崩溃了。


> 对操作系统来说,创建一个线程的代价是十分昂贵的, 需要给它分配内存、列入调度,同时在线程切换的时候还要执行内存换页,CPU 的缓存被 清空,切换回来的时候还要重新从内存中读取信息,破坏了数据的局部性。


**Worker Thread**是一种线程池的设计模式，其过程是初始化一个工厂，和n个工人的线程，并且这几个工人始终在等待任务的到来。工厂接待接到任务后，将该任务添加到工厂，工人拿到任务后执行该任务，结束后继续等待任务的到来。

**Worker Thread**模块类_https://blog.csdn.net/qq_31350373/article/details/80455207_
```java
Channel; //工厂，用来初始化工人线程，请求队列大小，添加请求，拿出请求的任务。
ClientThread; //工厂接待，接到任务后，将任务放到工厂请求队列中。
Request; //实际任务。
WorkerThread; //工人线程。请求队列中有任务就拿出任务执行，无任务就等待。
```

从上面设计可以看出，在最开始就初始化一个工厂和几个线程，有任务到来，则用工人线程处理此任务，处理完不销毁线程，而是继续等待。

然而此设计模式中，ClientThread也是一个线程，即每次任务添加都是通过新创建一个线程来实现的，也就是这种设计模式也会不断创建销毁线程，这与使用多线程的初衷相违背。

优化思路：添加任务不再使用线程，而是使用一般的类即可。

引出问题：但是这样造成的问题就是如果请求队列已经满了，则不能继续添加新任务，此时会使主线程堵塞，需要等待工人处理完一个任务才能再次添加，如果时间过长，则会出现request fail timeout。

解决办法：增加请求队列大小或者增加工人线程。
